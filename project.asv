%%% Project
clc
clear
% Generate color palette
% 1. 16 Standard ANSI colors
ansi = [0,0,0; 128,0,0; 0,128,0; 128,128,0; 0,0,128; 128,0,128; 0,128,128; 192,192,192;
        128,128,128; 255,0,0; 0,255,0; 255,255,0; 0,0,255; 255,0,255; 0,255,255; 255,255,255] / 255;

% 2. 216 colors (the 6x6x6 color cube)
vals = [0, 95, 135, 175, 215, 255] / 255;
[R, G, B] = ndgrid(vals, vals, vals);
cube = [R(:), G(:), B(:)];

% 3. 24 Grayscale levels (gradient from dark to light)
grays_val = linspace(8, 238, 24)' / 255;
grays = [grays_val, grays_val, grays_val];

% Combine into the final 256x3 dataset
my_palette = [ansi; cube; grays];
my_palette = my_palette(1:256, :); % Final array

%% Visualize the colors 
% 1. Reshape the 256x3 palette into a 16x16 grid
% Since each color is an RGB triplet, the final size is 16x16x3
palette_grid = reshape(my_palette, [16, 16, 3]);

% 2. Display the grid
figure;
imshow(palette_grid, 'InitialMagnification', 'fit');
axis on;
title('256 Color Dataset (16x16 Grid)');

% Optional: Label the axes to help identify specific color indices
xlabel('Column');
ylabel('Row');

%% Load Image and get its main color clusters
clc
img_org = im2double(imread("peppers_color.tif"));
img_work = img_org;

% Get dimenssions of input image
[rows, cols, channels] = size(img_org);
% Reshape the original image for k-means clustering
%pixel_data = rgb2lab(reshape(img_work, rows * cols, channels));
%num_colors = 100;
%[idx, C] = kmeans(pixel_data, num_colors, 'MaxIter', 200);




% Convert original image to CIELAB
img_lab = rgb2lab(img_org);

% Flatten to Nx3 list of pixels
pixel_data_lab = reshape(img_lab, [], 3);

% Convert dataset to CIELAB
my_palette_3d = reshape(my_palette, [256, 1, 3]);
my_palette_lab = reshape(rgb2lab(my_palette_3d), [256, 3]);

% The amount of colors in the final palette
num_colors = 64; 

% Perform K-means clustering
[~, image_centroids_lab] = kmeans(pixel_data_lab, num_colors, 'MaxIter', 100, 'EmptyAction', 'drop');

% Map centroids to dataset
idx = knnsearch(my_palette_lab, image_centroids_lab);

% Remove duplicates 
unique_idx = unique(idx);

% Pull the final colors from the ORIGINAL RGB palette for viewing
repro_palette = my_palette(unique_idx, :);

% Check how many unique colors we actually ended up with
actual_num_colors = size(repro_palette, 1);

% Visualize
figure;
subplot(1,2,1); 
imshow(img_org); % Fixed variable name
title('Original Image');

subplot(1,2,2); 
% Create a swatch using the actual number of extracted colors
% repelem creates nice clean blocks without interpolation blur
swatch_blocks = repelem(repro_palette, 20, 20); 
swatch_img = reshape(swatch_blocks, actual_num_colors * 20, 20, 3);

imshow(swatch_img); 
title(sprintf('Optimized Subset (%d Colors)', actual_num_colors));


% test 

for i = 1:8:512
    for j = 1:8:512
        optimal_r = sum(sum(im(i:i+7, j:j+7, 1)))/40;
        optimal_g = sum(sum(im(i:i+7, j:j+7, 2)))/40;
        optimal_b = sum(sum(im(i:i+7, j:j+7, 3)))/40;

        current_block_rgb = zeros(1,1,3);
        current_block_rgb(:,:,1) = optimal_r;
        current_block_rgb(:,:,2) = optimal_g;
        current_block_rgb(:,:,3) = optimal_b;

        current_block_lab = rgb2lab(current_block_rgb);

        current_block_lab = [current_block_lab(:,:,1), current_block_lab(:,:,2), current_block_lab(:,:,3)];

        distances = sqrt(sum((repro_palette - current_block_lab).^2, 2));
        
        [~, closest_idx] = min(distances);
        best_lab = C(closest_idx, :);
        best_rgb = lab2rgb(best_lab);

        im2(i:i+7, j:j+7, 1) = circle .* best_rgb(1);
        im2(i:i+7, j:j+7, 2) = circle .* best_rgb(2);
        im2(i:i+7, j:j+7, 3) = circle .* best_rgb(3);
    end
end

%%












circle = [0 0 0 1 1 0 0 0;
          0 0 1 1 1 1 0 0;
          0 1 1 1 1 1 1 0;
          1 1 1 1 1 1 1 1;
          1 1 1 1 1 1 1 1;
          0 1 1 1 1 1 1 0;
          0 0 1 1 1 1 0 0;
          0 0 0 1 1 0 0 0;];

circle_rgb = zeros(8,8,3);
circle_rgb(:,:,1) = circle;
circle_rgb(:,:,2) = circle;
circle_rgb(:,:,3) = circle;

g = [0 0 0 0 1 0 0 0 0;
     0 0 0 1 1 1 0 0 0;
     0 0 1 1 1 1 1 0 0;
     0 1 1 1 1 1 1 1 0;
     0 1 1 1 1 1 1 1 0;

     0 0 1 1 1 1 1 0 0;
     0 0 0 1 1 1 0 0 0;
     0 0 0 0 1 0 0 0 0;];




circle_lab = rgb2lab(circle_rgb);
im_lab = rgb2lab(im);

for i = 1:8:512
    for j = 1:8:512
        optimal_r = sum(sum(im(i:i+7, j:j+7, 1)))/40;
        optimal_g = sum(sum(im(i:i+7, j:j+7, 2)))/40;
        optimal_b = sum(sum(im(i:i+7, j:j+7, 3)))/40;

        current_block_rgb = zeros(1,1,3);
        current_block_rgb(:,:,1) = optimal_r;
        current_block_rgb(:,:,2) = optimal_g;
        current_block_rgb(:,:,3) = optimal_b;

        current_block_lab = rgb2lab(current_block_rgb);

%         current_pixel_lab = reshape(rgb2lab(test), 1, 3);
        current_block_lab = [current_block_lab(:,:,1), current_block_lab(:,:,2), current_block_lab(:,:,3)];

        distances = sqrt(sum((C - current_block_lab).^2, 2));
        
        [~, closest_idx] = min(distances);
        best_lab = C(closest_idx, :);
        best_rgb = lab2rgb(best_lab);

        im2(i:i+7, j:j+7, 1) = circle .* best_rgb(1);
        im2(i:i+7, j:j+7, 2) = circle .* best_rgb(2);
        im2(i:i+7, j:j+7, 3) = circle .* best_rgb(3);
%         im2(i:i+7, j:j+7, 1) = optimal_r;
%         im2(i:i+7, j:j+7, 2) = optimal_g;
%         im2(i:i+7, j:j+7, 3) = optimal_b;
    end
end


% block_size = 8;
% scale_factor = 1 / block_size;
% 
% small_img = imresize(im, scale_factor, 'box');
% [s_rows, s_cols, ~] = size(small_img);
% 
% small_pixels = reshape(small_img, s_rows * s_cols, channels);
% 
% distances = pdist2(small_pixels, C); 
% 
% [~, block_idx] = min(distances, [], 2); 
% 
% quantized_small_pixels = C(block_idx, :);
% quantized_small_img = reshape(quantized_small_pixels, s_rows, s_cols, channels);
% 
% blocky_img = lab2rgb(imresize(quantized_small_img, block_size, 'nearest'));
% 


subplot(1, 2, 1);
imshow(im);

subplot(1, 2, 2);
imshow(im2);




%%

 subplot(1,2,1)
 imshow(im)
 
 subplot(1,2,2)
 imshow(im2)

 quantized_pixel_data = C(idx, :);
 quantized_img = reshape(quantized_pixel_data, rows, cols, channels);

 subplot(1, 2, 1);
 imshow(im); 
 
 subplot(1, 2, 2);
 imshow(quantized_img);

%%
clc
clear

circle = [0 0 0 1 1 0 0 0;
          0 0 1 1 1 1 0 0;
          0 1 1 1 1 1 1 0;
          1 1 1 1 1 1 1 1;
          1 1 1 1 1 1 1 1;
          0 1 1 1 1 1 1 0;
          0 0 1 1 1 1 0 0;
          0 0 0 1 1 0 0 0;];

im = im2double(imread("peppers_color.tif"));

im(1:8, 1:8, 1);

target_r_sum = sum(sum(im(1:8, 1:8, 1)))
circle = circle .* target_r_sum/sum(sum(circle))

sum(sum(circle))

%%

clc
clear

im = im2double(imread("peppers_color.tif"));






















